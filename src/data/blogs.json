{
  "blogs": [
    {
      "id": 1,
      "title": "Building Modern Web Applications with Next.js",
      "slug": "building-modern-web-applications-nextjs",
      "excerpt": "Discover how to create fast, scalable web applications using Next.js with server-side rendering and modern React features.",
      "content": "# Building Modern Web Applications with Next.js\n\nNext.js has revolutionized the way we build React applications by providing a powerful framework that combines the best of server-side rendering, static site generation, and client-side rendering.\n\n## Why Choose Next.js?\n\n- **Performance**: Built-in optimizations for images, fonts, and scripts\n- **SEO-friendly**: Server-side rendering for better search engine visibility\n- **Developer Experience**: Hot reloading, TypeScript support, and more\n- **Deployment**: Easy deployment with Vercel or any hosting platform\n\n## Key Features\n\n### 1. File-based Routing\nNext.js uses a file-based routing system that makes creating pages intuitive and straightforward.\n\n### 2. API Routes\nBuild your backend API alongside your frontend application.\n\n### 3. Image Optimization\nAutomatic image optimization with the Next.js Image component.\n\n## Getting Started\n\nTo create a new Next.js project:\n\n```bash\nnpx create-next-app@latest my-app\ncd my-app\nnpm run dev\n```\n\n## Conclusion\n\nNext.js provides an excellent foundation for building modern web applications with React.",
      "author": "Abdo Raquibi",
      "date": "2024-01-15",
      "read_time": "8 min read",
      "category": "Frontend",
      "tags": "Next.js, React, SSR, Web Development",
      "image": "/images/nextjs-blog.jpg",
      "meta_description": "Learn how to build modern web applications with Next.js, featuring SSR, static generation, and optimal performance.",
      "meta_keywords": "Next.js, React, SSR, web development, frontend",
      "is_published": true,
      "is_featured": true,
      "view_count": 246,
      "created_at": "2024-01-15T10:00:00Z",
      "updated_at": "2025-09-22T08:35:12.800Z"
    },
    {
      "id": 2,
      "title": "Mastering Tailwind CSS: A Complete Guide",
      "slug": "mastering-tailwind-css-complete-guide",
      "excerpt": "Learn to build beautiful UIs with Tailwind CSS utility-first approach and modern design principles.",
      "content": "# Mastering Tailwind CSS: A Complete Guide\n\nTailwind CSS has become the go-to choice for developers who want to build beautiful interfaces quickly without writing custom CSS.\n\n## What is Tailwind CSS?\n\nTailwind CSS is a utility-first CSS framework that provides low-level utility classes to build custom designs directly in your markup.\n\n## Key Benefits\n\n- **Rapid Development**: Build interfaces faster with pre-built utilities\n- **Consistent Design**: Built-in design system with spacing, colors, and typography\n- **Responsive Design**: Mobile-first responsive utilities\n- **Customizable**: Easily customize the design system to match your brand\n\n## Getting Started\n\nInstall Tailwind CSS in your project:\n\n```bash\nnpm install -D tailwindcss\nnpx tailwindcss init\n```\n\n## Common Patterns\n\n### Card Component\n```html\n<div class=\"bg-white rounded-lg shadow-md p-6\">\n  <h2 class=\"text-xl font-bold mb-4\">Card Title</h2>\n  <p class=\"text-gray-600\">Card content goes here.</p>\n</div>\n```\n\n### Button Variants\n```html\n<button class=\"bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded\">\n  Primary Button\n</button>\n```\n\n## Best Practices\n\n1. Use component abstraction for repeated patterns\n2. Leverage Tailwind's design tokens\n3. Utilize responsive utilities effectively\n4. Customize the configuration for your needs\n\n## Conclusion\n\nTailwind CSS empowers developers to create beautiful, responsive designs without leaving their HTML.",
      "author": "Abdo Raquibi",
      "date": "2024-01-05",
      "read_time": "6 min read",
      "category": "Design",
      "tags": "CSS, Tailwind CSS, Design, Frontend",
      "image": "/images/tailwind-blog.jpg",
      "meta_description": "Learn to build beautiful UIs with Tailwind CSS utility-first approach and modern design principles.",
      "meta_keywords": "Tailwind CSS, CSS, design, utility-first, frontend",
      "is_published": true,
      "is_featured": true,
      "view_count": 216,
      "created_at": "2024-01-05T10:00:00Z",
      "updated_at": "2025-09-22T08:34:33.336Z"
    },
    {
      "id": 3,
      "title": "Advanced React Patterns and Best Practices",
      "slug": "advanced-react-patterns-best-practices",
      "excerpt": "Explore advanced React patterns including hooks, context, and performance optimization techniques for building scalable applications.",
      "content": "# Advanced React Patterns and Best Practices\n\nAs React applications grow in complexity, it's essential to understand advanced patterns and best practices that help maintain clean, scalable, and performant code.\n\n## Custom Hooks\n\nCustom hooks allow you to extract component logic into reusable functions.\n\n```jsx\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  const setValue = (value) => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n```\n\n## Context API for State Management\n\nThe Context API provides a way to share state across components without prop drilling.\n\n```jsx\nconst ThemeContext = createContext();\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n## Performance Optimization\n\n### React.memo\nUse React.memo to prevent unnecessary re-renders:\n\n```jsx\nconst MemoizedComponent = React.memo(({ data }) => {\n  return <div>{data.name}</div>;\n});\n```\n\n### useMemo and useCallback\nOptimize expensive calculations and function references:\n\n```jsx\nconst expensiveValue = useMemo(() => {\n  return data.reduce((acc, item) => acc + item.value, 0);\n}, [data]);\n\nconst handleClick = useCallback(() => {\n  // Handle click logic\n}, [dependency]);\n```\n\n## Component Composition\n\nUse composition over inheritance for flexible component design:\n\n```jsx\nfunction Card({ children, className }) {\n  return (\n    <div className={`card ${className}`}>\n      {children}\n    </div>\n  );\n}\n\nfunction CardHeader({ children }) {\n  return <div className=\"card-header\">{children}</div>;\n}\n\nfunction CardBody({ children }) {\n  return <div className=\"card-body\">{children}</div>;\n}\n```\n\n## Error Boundaries\n\nImplement error boundaries to gracefully handle errors:\n\n```jsx\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}\n```\n\n## Conclusion\n\nMastering these advanced React patterns will help you build more maintainable, performant, and scalable applications.",
      "author": "Abdo Raquibi",
      "date": "2024-01-20",
      "read_time": "12 min read",
      "category": "Frontend",
      "tags": "React, JavaScript, Patterns, Performance",
      "image": "/images/react-patterns.jpg",
      "meta_description": "Explore advanced React patterns including hooks, context, and performance optimization techniques for building scalable applications.",
      "meta_keywords": "React, hooks, context, performance, patterns, JavaScript",
      "is_published": true,
      "is_featured": true,
      "view_count": 321,
      "created_at": "2024-01-20T10:00:00Z",
      "updated_at": "2025-09-22T08:21:04.978Z"
    },
    {
      "id": 4,
      "title": "Full-Stack Development with Node.js and Express",
      "slug": "fullstack-development-nodejs-express",
      "excerpt": "Build complete web applications using Node.js, Express, and modern development practices for backend API development.",
      "content": "# Full-Stack Development with Node.js and Express\n\nNode.js and Express provide a powerful foundation for building scalable backend APIs and full-stack web applications.\n\n## Setting Up Your Environment\n\nFirst, let's set up a new Node.js project:\n\n```bash\nmkdir my-api\ncd my-api\nnpm init -y\nnpm install express cors helmet morgan\nnpm install -D nodemon\n```\n\n## Basic Express Server\n\nCreate a basic Express server:\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware\napp.use(helmet());\napp.use(cors());\napp.use(morgan('combined'));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Routes\napp.get('/', (req, res) => {\n  res.json({ message: 'Welcome to the API' });\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n## RESTful API Design\n\nImplement RESTful endpoints:\n\n```javascript\n// Users routes\napp.get('/api/users', getAllUsers);\napp.get('/api/users/:id', getUserById);\napp.post('/api/users', createUser);\napp.put('/api/users/:id', updateUser);\napp.delete('/api/users/:id', deleteUser);\n```\n\n## Database Integration\n\nConnect to MongoDB using Mongoose:\n\n```javascript\nconst mongoose = require('mongoose');\n\nmongoose.connect('mongodb://localhost:27017/myapp', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n});\n\n// User schema\nconst userSchema = new mongoose.Schema({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n  createdAt: { type: Date, default: Date.now },\n});\n\nconst User = mongoose.model('User', userSchema);\n```\n\n## Authentication with JWT\n\nImplement JWT authentication:\n\n```javascript\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\n\n// Generate token\nfunction generateToken(userId) {\n  return jwt.sign({ userId }, process.env.JWT_SECRET, {\n    expiresIn: '24h',\n  });\n}\n\n// Verify token middleware\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n\n  if (!token) {\n    return res.sendStatus(401);\n  }\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {\n    if (err) return res.sendStatus(403);\n    req.userId = decoded.userId;\n    next();\n  });\n}\n```\n\n## Error Handling\n\nImplement comprehensive error handling:\n\n```javascript\n// Error handling middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: 'Something went wrong!',\n    message: process.env.NODE_ENV === 'development' ? err.message : undefined,\n  });\n});\n```\n\n## API Documentation\n\nDocument your API using Swagger:\n\n```javascript\nconst swaggerJsdoc = require('swagger-jsdoc');\nconst swaggerUi = require('swagger-ui-express');\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'My API',\n      version: '1.0.0',\n      description: 'A simple Express API',\n    },\n  },\n  apis: ['./routes/*.js'],\n};\n\nconst specs = swaggerJsdoc(options);\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));\n```\n\n## Testing\n\nWrite tests using Jest and Supertest:\n\n```javascript\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('GET /api/users', () => {\n  test('should return all users', async () => {\n    const response = await request(app)\n      .get('/api/users')\n      .expect(200);\n    \n    expect(response.body).toHaveProperty('users');\n  });\n});\n```\n\n## Conclusion\n\nNode.js and Express provide a solid foundation for building scalable backend applications. Focus on proper architecture, security, and testing for production-ready applications.",
      "author": "Abdo Raquibi",
      "date": "2024-01-25",
      "read_time": "15 min read",
      "category": "Backend",
      "tags": "Node.js, Express, API, Backend, Full-Stack",
      "image": "/images/nodejs-express.jpg",
      "meta_description": "Build complete web applications using Node.js, Express, and modern development practices for backend API development.",
      "meta_keywords": "Node.js, Express, API, backend, full-stack, JavaScript",
      "is_published": true,
      "is_featured": false,
      "view_count": 157,
      "created_at": "2024-01-25T10:00:00Z",
      "updated_at": "2025-09-22T08:21:25.426Z"
    },
    {
      "id": 5,
      "title": "TypeScript Best Practices for Large Projects",
      "slug": "typescript-best-practices-large-projects",
      "excerpt": "Learn essential TypeScript patterns and configurations for maintaining type safety in large-scale applications.",
      "content": "# TypeScript Best Practices for Large Projects\n\nTypeScript brings static typing to JavaScript, making it easier to catch errors early and maintain large codebases. Here are essential practices for large-scale projects.\n\n## Project Configuration\n\nStart with a robust `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"noImplicitReturns\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Type Definitions\n\n### Interface vs Type Aliases\n\nUse interfaces for object shapes:\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  createdAt: Date;\n}\n\ninterface CreateUserRequest {\n  name: string;\n  email: string;\n}\n```\n\nUse type aliases for unions and computed types:\n\n```typescript\ntype Status = 'pending' | 'approved' | 'rejected';\ntype UserWithStatus = User & { status: Status };\ntype UserKeys = keyof User;\n```\n\n## Utility Types\n\nLeverage TypeScript's built-in utility types:\n\n```typescript\n// Pick specific properties\ntype UserSummary = Pick<User, 'id' | 'name'>;\n\n// Omit specific properties\ntype CreateUser = Omit<User, 'id' | 'createdAt'>;\n\n// Make all properties optional\ntype PartialUser = Partial<User>;\n\n// Make all properties required\ntype RequiredUser = Required<User>;\n```\n\n## Generic Types\n\nCreate reusable generic types:\n\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface PaginatedResponse<T> extends ApiResponse<T[]> {\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n  };\n}\n\n// Usage\ntype UsersResponse = PaginatedResponse<User>;\ntype UserResponse = ApiResponse<User>;\n```\n\n## Error Handling\n\nImplement type-safe error handling:\n\n```typescript\ntype Result<T, E = Error> = \n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function fetchUser(id: string): Promise<Result<User>> {\n  try {\n    const user = await userService.getUser(id);\n    return { success: true, data: user };\n  } catch (error) {\n    return { success: false, error: error as Error };\n  }\n}\n\n// Usage\nconst result = await fetchUser('123');\nif (result.success) {\n  console.log(result.data.name); // TypeScript knows this is User\n} else {\n  console.error(result.error.message); // TypeScript knows this is Error\n}\n```\n\n## Discriminated Unions\n\nUse discriminated unions for complex state management:\n\n```typescript\ntype LoadingState = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: User[] }\n  | { status: 'error'; error: string };\n\nfunction handleState(state: LoadingState) {\n  switch (state.status) {\n    case 'idle':\n      return 'Not started';\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Loaded ${state.data.length} users`; // data is available\n    case 'error':\n      return `Error: ${state.error}`; // error is available\n  }\n}\n```\n\n## Type Guards\n\nImplement type guards for runtime type checking:\n\n```typescript\nfunction isUser(obj: any): obj is User {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    typeof obj.id === 'string' &&\n    typeof obj.name === 'string' &&\n    typeof obj.email === 'string' &&\n    obj.createdAt instanceof Date\n  );\n}\n\nfunction processUserData(data: unknown) {\n  if (isUser(data)) {\n    // TypeScript now knows data is User\n    console.log(data.name);\n  }\n}\n```\n\n## Module Augmentation\n\nExtend third-party types when needed:\n\n```typescript\n// Extend Express Request type\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: User;\n    }\n  }\n}\n```\n\n## Testing Types\n\nTest your types with type assertions:\n\n```typescript\n// Type tests\ntype AssertEqual<T, U> = T extends U ? (U extends T ? true : false) : false;\n\ntype Test1 = AssertEqual<UserSummary, Pick<User, 'id' | 'name'>>; // true\ntype Test2 = AssertEqual<CreateUser, Omit<User, 'id' | 'createdAt'>>; // true\n```\n\n## Performance Considerations\n\n1. Use `const assertions` for better inference:\n```typescript\nconst colors = ['red', 'green', 'blue'] as const;\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n```\n\n2. Prefer `unknown` over `any`:\n```typescript\nfunction processData(data: unknown) {\n  if (typeof data === 'string') {\n    return data.toUpperCase(); // Safe\n  }\n}\n```\n\n## Conclusion\n\nFollowing these TypeScript best practices will help you build more maintainable, type-safe applications that scale effectively as your project grows.",
      "author": "Abdo Raquibi",
      "date": "2024-01-30",
      "read_time": "10 min read",
      "category": "Frontend",
      "tags": "TypeScript, JavaScript, Types, Best Practices",
      "image": "/images/typescript-guide.jpg",
      "meta_description": "Learn essential TypeScript patterns and configurations for maintaining type safety in large-scale applications.",
      "meta_keywords": "TypeScript, JavaScript, types, best practices, large projects",
      "is_published": true,
      "is_featured": false,
      "view_count": 89,
      "created_at": "2024-01-30T10:00:00Z",
      "updated_at": "2024-01-30T10:00:00Z"
    }
  ]
}